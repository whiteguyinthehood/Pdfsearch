<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>DocuSearch v33.2 Stable</title>
    
    <link rel="manifest" href="./manifest.json" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#020617">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/3143/3143460.png">

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js'></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
      body { background-color: #020617; color: #e2e8f0; user-select: none; font-family: system-ui, -apple-system, sans-serif; }
      .pt-safe-top { padding-top: env(safe-area-inset-top); }
      .pb-safe-bottom { padding-bottom: env(safe-area-inset-bottom); }
      .scrollbar-hide::-webkit-scrollbar { display: none; }
      .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
      .magic-link { transition: all 0.2s; border-radius: 4px; padding: 0 2px; }
      .magic-link:active { background-color: #4338ca; color: white; transform: scale(1.05); display: inline-block; }
      #emergency-controls { position: fixed; bottom: 20px; left: 20px; z-index: 9999; display: none; }
      .reset-btn { background: #ef4444; color: white; padding: 10px 15px; border-radius: 8px; font-weight: bold; font-size: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border: 1px solid #b91c1c; }
      #error-log { display: none; position: fixed; top: 0; left: 0; right: 0; background: #7f1d1d; color: white; padding: 20px; z-index: 10000; font-family: monospace; font-size: 12px; white-space: pre-wrap; border-bottom: 2px solid #f87171; }
      .slide-up { animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1); }
      @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
    </style>
  </head>
  <body>
    
    <div id="error-log"></div>
    <div id="emergency-controls">
      <button onclick="if(confirm('Factory Reset? This deletes your library to fix crashes.')){ localStorage.clear(); indexedDB.deleteDatabase('DocuSearch_Forge_V2'); window.location.reload(); }" class="reset-btn">⚠️ FACTORY RESET</button>
    </div>

    <div id="root"></div>

    <script>
      window.onerror = function(msg, url, line, col, error) {
        document.getElementById('error-log').style.display = 'block';
        document.getElementById('error-log').innerText = "CRITICAL ERROR:\n" + msg + "\nLine: " + line;
        document.getElementById('emergency-controls').style.display = 'block';
      };
    </script>

    <script type="text/babel">
      try {
        const { useState, useEffect, useRef, useMemo, useCallback } = React;
        const { createRoot } = ReactDOM;

        const DB_NAME = 'DocuSearch_Forge_V2';
        const STORE_NAME = 'files_store';
        const PDFJS_CDN = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
        const PDFJS_WORKER_CDN = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
        const BATCH_SIZE = 3;

        // --- ICONS ---
        const Icon = ({ path, size = 20, className = "", ...props }) => ( <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props} dangerouslySetInnerHTML={{ __html: path }} /> );
        const ICONS = {
          search: '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>',
          upload: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>',
          folder: '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>',
          combine: '<path d="M8 2h8a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z"></path><line x1="12" y1="2" x2="12" y2="22"></line><path d="M16 16v-8"></path><path d="M8 16v-8"></path>',
          arrowLeft: '<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>',
          trash: '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>',
          settings: '<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>',
          download: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>',
          speaker: '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>',
          stop: '<rect x="6" y="6" width="12" height="12"></rect>',
          listIcon: '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>',
          star: '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>',
          starFilled: '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" fill="currentColor"></polygon>',
          edit: '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>',
          check: '<polyline points="20 6 9 17 4 12"></polyline>',
          save: '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>',
          filter: '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>',
          close: '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>',
          gem: '<path d="M6 3h12l4 6-10 13L2 9z"></path>',
          select: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>',
          sparkles: '<path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"></path>',
          tag: '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>',
          wand: '<path d="M15 4V2"></path><path d="M15 16v-2"></path><path d="M8 9h2"></path><path d="M20 9h2"></path><path d="M17.8 11.8 19 13"></path><path d="M15 9h0"></path><path d="M17.8 6.2 19 5"></path><path d="m3 21 9-9"></path><path d="M12.2 6.2 11 5"></path>'
        };

        // --- GEMINI 2.5 API ---
        const callGemini = async (base64Image, apiKey) => {
          if (!apiKey) throw new Error("Missing API Key");
          const cleanBase64 = base64Image.split(',')[1];
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contents: [{ parts: [{ text: "You are a Data Extractor. Output only clean Markdown. Use # H1 for Main Titles, ## H2 for sections. Format data tables as markdown tables. Fix OCR errors. Do not use ```markdown code blocks." }, { inline_data: { mime_type: "image/jpeg", data: cleanBase64 } } ] }] })
          });
          if (!response.ok) throw new Error("API Error: " + response.status);
          const data = await response.json();
          return data.candidates?.[0]?.content?.parts?.[0]?.text || "AI Extraction Failed";
        };

        const cleanTextBatch = async (textArray, apiKey) => {
          if (!apiKey) throw new Error("Missing API Key");
          const MARKER = "|||PAGE|||"; 
          const rawBlock = textArray.join(` ${MARKER} `);
          const prompt = `You are a Text Cleaner. Your job is to fix OCR errors, spacing, and broken hyphens. RULES: 1. Output the text EXACTLY as structured but cleaned. 2. YOU MUST PRESERVE the separator "${MARKER}" between pages. 3. Do not summarize. 4. Return only cleaned text.`;
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contents: [{ parts: [{ text: prompt + "\n\nTEXT TO CLEAN:\n" + rawBlock }] }] })
          });
          if (!response.ok) throw new Error("Batch Clean Failed");
          const data = await response.json();
          const cleanBlock = data.candidates?.[0]?.content?.parts?.[0]?.text || "";
          return cleanBlock.split(MARKER).map(s => s.trim());
        };

              // --- ADVANCED JS SUITE (SVG + LAYERS) ---
        // TOOL 1: Disables Shadow/Background Layers (Fixes "Echo")
        const disableShadowLayers = async (pdfDoc) => {
          const optionalContentConfig = await pdfDoc.getOptionalContentConfig();
          const groups = optionalContentConfig.getOrder();
          if (!groups) return;
          groups.forEach((group) => {
            const name = group.name ? group.name.toLowerCase() : "";
            if (name.includes("shadow") || name.includes("background") || name.includes("multiply")) {
              console.log(`[Layer Scalpel] Disabling: ${group.name}`);
              optionalContentConfig.setVisibility(group.id, false);
            }
          });
        };

        // TOOL 2: Extracts Text from SVG DOM (Fixes Tables & Layouts)
        const extractTextFromSVG = async (pdfDoc, pageNum) => {
          try {
            const page = await pdfDoc.getPage(pageNum);
            const operatorList = await page.getOperatorList();
            const viewport = page.getViewport({ scale: 1.0 });
            
            // FIX: Access pdfjsLib via window
            const svgGfx = new window.pdfjsLib.SVGGraphics(page.commonObjs, page.objs);
            const svg = await svgGfx.getSVG(operatorList, viewport);
            
            const rawElements = Array.from(svg.querySelectorAll("text > tspan, text"));
            const textItems = rawElements.map(el => {
              const transform = el.getAttribute("transform");
              let x = 0, y = 0;
              if (transform && transform.startsWith("matrix")) {
                 const matrix = transform.match(/matrix\(([^)]+)\)/)[1].split(' ').map(parseFloat);
                 x = matrix[4]; y = matrix[5];
              } else {
                 x = parseFloat(el.getAttribute("x")) || 0; y = parseFloat(el.getAttribute("y")) || 0;
              }
              return { text: el.textContent, x, y };
            });

            // Sort: Top-to-Bottom, then Left-to-Right
            textItems.sort((a, b) => {
               const rowDiff = Math.abs(a.y - b.y);
               if (rowDiff < 10) return a.x - b.x; 
               return a.y - b.y;
            });
            return textItems.map(t => t.text).join(" ");
            
          } catch (e) {
            console.warn("SVG Extract Failed, falling back:", e);
            // Fallback to standard text if SVG fails
            const page = await pdfDoc.getPage(pageNum);
            const txt = await page.getTextContent();
            return txt.items.map(i => i.str).join(' ');
          }
        };

        // TOOL 3: Heuristic Cleaner (Final Polish)
        const cleanText = (str) => {
          if (!str) return "";
          let s = str.replace(/ﬁ/g, 'fi').replace(/ﬂ/g, 'fl').replace(/ﬃ/g, 'ffi').replace(/ﬀ/g, 'ff');
          s = s.replace(/^Page \d+.*$/gm, '').replace(/^\d+ of \d+$/gm, '');
          s = s.replace(/([a-z,])\n(?=[a-z])/g, '$1 ');
          s = s.replace(/^([A-Z\s]{3,50})$/gm, '\n\n$1\n\n');
          return s.replace(/-\s+([a-z])/g, '$1').replace(/[ \t]{2,}/g, ' ').trim();
        };

        // --- DATABASE & STATE ---
        const openDB = () => new Promise((resolve, reject) => { 
          const r = indexedDB.open(DB_NAME, 1); 
          r.onupgradeneeded = (e) => { const db = e.target.result; if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME, { keyPath: 'id' }); }; 
          r.onsuccess = () => resolve(r.result); 
          r.onerror = () => reject(r.error); 
        });
        const saveFileToDB = async (data) => { const db = await openDB(); const tx = db.transaction(STORE_NAME, 'readwrite'); tx.objectStore(STORE_NAME).put(data); };
        const updateFileInDB = async (id, updates, cb) => { const db = await openDB(); const tx = db.transaction(STORE_NAME, 'readwrite'); const store = tx.objectStore(STORE_NAME); store.get(id).onsuccess = (e) => { const n={...e.target.result, ...updates}; store.put(n); if(cb) cb(n); }; };
        const processOutline = async (pdfDoc, items) => { const processed = []; for (const item of items) { let page = 1; try { if (item.dest) { const dest = typeof item.dest === 'string' ? await pdfDoc.getDestination(item.dest) : item.dest; if (dest) { const ref = dest[0]; const index = await pdfDoc.getPageIndex(ref); page = index + 1; } } } catch(e) {} const children = item.items?.length ? await processOutline(pdfDoc, item.items) : []; processed.push({ title: item.title, page, children }); } return processed; };

        const ToCList = ({ items, level = 0, onSelect }) => ( <div className="flex flex-col">{items.map((it, i) => ( <div key={i}> <button onClick={() => onSelect(it.page)} className="text-left py-3 px-4 w-full border-b border-slate-800 hover:bg-slate-800 text-sm truncate text-slate-300 active:bg-indigo-900/30" style={{paddingLeft: `${level*16+16}px`}}><span className="font-medium text-slate-200">{it.title}</span> <span className="text-xs text-slate-500 ml-2">(Pg {it.page})</span></button> {it.children && <ToCList items={it.children} level={level+1} onSelect={onSelect} />} </div> ))}</div> );
        
        const HighlightedText = ({ text, keywords, onLinkClick }) => { 
          if (!text) return null; 
          if (!keywords || !Array.isArray(keywords) || keywords.length === 0) return <p className="text-lg leading-loose text-slate-300 font-serif whitespace-pre-wrap">{text}</p>; 
          const terms = keywords.filter(k => k && k.term).map(k => k.term); 
          if(terms.length === 0) return <p className="text-lg leading-loose text-slate-300 font-serif whitespace-pre-wrap">{text}</p>; 
          const pattern = new RegExp(`(${terms.sort((a,b)=>b.length-a.length).map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})`, 'gi'); 
          const parts = text.split(pattern); 
          return ( <p className="text-lg leading-loose text-slate-300 font-serif whitespace-pre-wrap"> {parts.map((part, i) => { const match = keywords.find(k => k.term.toLowerCase() === part.toLowerCase()); if (match) { return <span key={i} onClick={(e) => { e.stopPropagation(); onLinkClick(part); }} className={`font-bold underline cursor-pointer magic-link ${match.important ? 'text-amber-400 decoration-amber-600 decoration-4' : 'text-indigo-400 decoration-indigo-600 decoration-2'}`}>{part}</span>; } return part; })} </p> ); 
        };

        function App() {
          const [files, setFiles] = useState([]); 
          const [queue, setQueue] = useState([]);
          const [isProcessing, setIsProcessing] = useState(false);
          const [searchQuery, setSearchQuery] = useState('');
          const [searchResults, setSearchResults] = useState([]);
          const [selectedFile, setSelectedFile] = useState(null);
          const [statusMsg, setStatusMsg] = useState('');
          const [isViewerOpen, setIsViewerOpen] = useState(false);
          const [showSettings, setShowSettings] = useState(false);
          const [tagQuery, setTagQuery] = useState("");
          const [showTagModal, setShowTagModal] = useState(false);
          const [activeTagFilter, setActiveTagFilter] = useState(null);
          const [selectionMode, setSelectionMode] = useState(false);
          const [selectedIds, setSelectedIds] = useState(new Set());
          const [apiKey, setApiKey] = useState(localStorage.getItem('gemini_api_key') || '');
          const [savedSearches, setSavedSearches] = useState([]);
          
          const [showSavedSearches, setShowSavedSearches] = useState(false);
          const [isEditingKeywords, setIsEditingKeywords] = useState(false);
          const [keywordToEdit, setKeywordToEdit] = useState(null);
          const [deferredPrompt, setDeferredPrompt] = useState(null);
          const [showReuploadModal, setShowReuploadModal] = useState(false);
          const [isEditingText, setIsEditingText] = useState(false);
          const [editedTextContent, setEditedTextContent] = useState("");
          const [showToC, setShowToC] = useState(false);
          const [isSpeaking, setIsSpeaking] = useState(false);

          const fileInputRef = useRef(null);
          const folderInputRef = useRef(null);
          const mergeInputRef = useRef(null);
          const importInputRef = useRef(null);
          const reuploadInputRef = useRef(null);

          useEffect(() => {
            const script = document.createElement('script'); script.src = PDFJS_CDN; script.onload = () => window.pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER_CDN; document.body.appendChild(script);
            
            // --- KILL SWITCH: UNREGISTER OLD WORKERS TO FIX "LINE 0" ERROR ---
            if('serviceWorker' in navigator) {
               navigator.serviceWorker.getRegistrations().then(function(registrations) {
                 for(let registration of registrations) {
                   console.log("Killing Worker:", registration);
                   registration.unregister();
                 }
               });
            }
            // navigator.serviceWorker.register('./service-worker.js'); // DISABLED TEMPORARILY

            window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); setDeferredPrompt(e); });
            loadLibrary();
            try { const saved = localStorage.getItem('docusearch_keywords_v2'); if(saved) { const parsed = JSON.parse(saved); if (Array.isArray(parsed)) setSavedSearches(parsed); } } catch(e) {}
            document.getElementById('emergency-controls').style.display = 'none';
          }, []);

                  const updateApiKey = (k) => { setApiKey(k); localStorage.setItem('gemini_api_key', k); };
          const loadLibrary = async () => { const db = await openDB(); const tx = db.transaction(STORE_NAME, 'readonly'); const req = tx.objectStore(STORE_NAME).getAll(); req.onsuccess = () => setFiles(req.result.sort((a,b) => b.added - a.added)); };
          const installApp = async () => { if (deferredPrompt) { deferredPrompt.prompt(); const { outcome } = await deferredPrompt.userChoice; if (outcome === 'accepted') setDeferredPrompt(null); }};

          // --- KEYWORD LOGIC ---
          const saveKeyword = (obj) => { const newK = savedSearches.some(k=>k.id===obj.id) ? savedSearches.map(k=>k.id===obj.id?obj:k) : [...savedSearches, obj]; setSavedSearches(newK); localStorage.setItem('docusearch_keywords_v2', JSON.stringify(newK)); };
          const deleteKeyword = (id) => { const newK = savedSearches.filter(k=>k.id!==id); setSavedSearches(newK); localStorage.setItem('docusearch_keywords_v2', JSON.stringify(newK)); };
          const toggleQuickSave = (term) => { if(!term.trim()) return; const exists = savedSearches.find(s => s.term.toLowerCase() === term.toLowerCase()); if (exists) deleteKeyword(exists.id); else saveKeyword({ id: Math.random().toString(36).substr(2,9), term, category: 'General', important: false }); };

          // QUEUE PROCESSOR
          useEffect(() => { if (queue.length > 0 && !isProcessing) processNextBatch(); }, [queue, isProcessing]);
          const processNextBatch = async () => {
            setIsProcessing(true);
            const batch = queue.slice(0, BATCH_SIZE);
            for (const file of batch) await processFile(file, queue.length);
            setQueue(prev => prev.slice(BATCH_SIZE));
            if (queue.length <= BATCH_SIZE) { setStatusMsg("Import Complete!"); setTimeout(()=>setStatusMsg(''), 2000); }
            setIsProcessing(false);
          };

          const processFile = async (file, remaining) => {
            try {
               const id = `${file.name}-${file.size}`; if(files.some(f=>f.id===id)) return;
               setStatusMsg(`Smart Scan: ${file.name} (${remaining})`);
               const url = URL.createObjectURL(file);
               const task = window.pdfjsLib.getDocument(url);
               const pdf = await task.promise;
               
               // 1. ACTIVATE LAYER SCALPEL
               await disableShadowLayers(pdf);
               
               let thumb = null;
               try { const p1 = await pdf.getPage(1); const vp = p1.getViewport({scale:0.5}); const cvs = document.createElement('canvas'); cvs.width=vp.width; cvs.height=vp.height; await p1.render({canvasContext:cvs.getContext('2d'), viewport:vp}).promise; thumb=cvs.toDataURL('image/jpeg',0.6); } catch(e){}

               // 2. ACTIVATE SVG EXTRACTION
               const textArr = [];
               for(let i=1; i<=pdf.numPages; i++){
                 const str = await extractTextFromSVG(pdf, i);
                 textArr.push(cleanText(str)); 
               }

               let toc = []; try { const outline = await pdf.getOutline(); if(outline) toc = await processOutline(pdf, outline); } catch(e) {}
               const data = { id, name: file.name, pageCount: pdf.numPages, textContent: textArr, thumbnail: thumb, tags: [], toc: toc, added: Date.now() };
               await saveFileToDB(data);
               setFiles(p => [data, ...p]);
               URL.revokeObjectURL(url);
            } catch(e) { console.error(e); }
          };

          const addToQueue = (newFiles) => { if (newFiles.length === 0) return; setQueue(prev => [...prev, ...newFiles]); };
          const handleFileSelect = (e) => { if (!window.pdfjsLib) return alert("Engine loading..."); const newFiles = Array.from(e.target.files).filter(f => f.name.toLowerCase().endsWith('.pdf')); addToQueue(newFiles); };
          
          const batchPolish = async () => {
             if (!apiKey) return alert("API Key Required");
             if (selectedIds.size === 0) return alert("Select files to polish");
             setStatusMsg("Polishing Text...");
             const db = await openDB();
             for (const id of selectedIds) {
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const file = await new Promise(r => store.get(id).onsuccess = e => r(e.target.result));
                try {
                   setStatusMsg(`Polishing: ${file.name}...`);
                   const cleanPages = await cleanTextBatch(file.textContent, apiKey);
                   if (cleanPages.length === file.textContent.length) {
                      file.textContent = cleanPages;
                      await new Promise(r => store.put(file).onsuccess = r);
                   } else { console.warn("Page mismatch, skipping save."); }
                } catch(err) { console.error(err); }
             }
             setStatusMsg("Polish Complete!");
             setSelectionMode(false); setSelectedIds(new Set()); loadLibrary();
          };

             const handleMergeSelect = async (e) => {
             const mergeFiles = Array.from(e.target.files);
             if (mergeFiles.length < 2) return alert("Select at least 2 PDFs.");
             
             // Option: Ask user if they want the "Heavy" processing
             if (!confirm("Compress & Convert to B/W?\n\nOK = Yes (Slower, smaller file, fixes layers)\nCancel = No (Standard Merge)")) {
                 // Standard Merge (Fallback logic if they click Cancel)
                 // ... You can re-paste the old logic here if you want both options, 
                 // but for now, let's focus on the Compressed version you asked for.
                 return; 
             }

             setStatusMsg("Initializing Compression Engine...");
             try {
                const newPdf = await PDFLib.PDFDocument.create();
                
                for (let fIdx = 0; fIdx < mergeFiles.length; fIdx++) {
                    const file = mergeFiles[fIdx];
                    const url = URL.createObjectURL(file);
                    const loadingTask = window.pdfjsLib.getDocument(url);
                    const pdf = await loadingTask.promise;
                    
                    for (let i = 1; i <= pdf.numPages; i++) {
                        setStatusMsg(`Processing: ${file.name} (Pg ${i}/${pdf.numPages})`);
                        
                        const page = await pdf.getPage(i);
                        // Scale 1.5 gives good readability vs size balance
                        const viewport = page.getViewport({ scale: 1.5 });
                        const canvas = document.createElement('canvas');
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        const ctx = canvas.getContext('2d');
                        
                        // 1. Render Page
                        await page.render({ canvasContext: ctx, viewport }).promise;
                        
                        // 2. Grayscale Filter (Pixel Manipulation)
                        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const d = imgData.data;
                        for (let p = 0; p < d.length; p += 4) {
                            // Simple luminosity method
                            const gray = (0.299 * d[p]) + (0.587 * d[p+1]) + (0.114 * d[p+2]);
                            d[p] = d[p+1] = d[p+2] = gray;
                        }
                        ctx.putImageData(imgData, 0, 0);
                        
                        // 3. Compress to JPEG (0.5 = 50% Quality)
                        const jpgUrl = canvas.toDataURL('image/jpeg', 0.4);
                        const jpgImageBytes = await fetch(jpgUrl).then(res => res.arrayBuffer());
                        
                        // 4. Add to New PDF
                        const embeddedImg = await newPdf.embedJpg(jpgImageBytes);
                        const newPage = newPdf.addPage([viewport.width, viewport.height]);
                        newPage.drawImage(embeddedImg, { x: 0, y: 0, width: viewport.width, height: viewport.height });
                    }
                    URL.revokeObjectURL(url);
                }
                
                setStatusMsg("Saving Compressed PDF...");
                const pdfBytes = await newPdf.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const fileObj = new File([blob], `Compressed_Merge_${new Date().toISOString().slice(0,10)}.pdf`, { type: 'application/pdf' });
                
                // Add to Queue & Auto-Download
                addToQueue([fileObj]);
                const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = fileObj.name; link.click();
                setStatusMsg("Done!");
                   };
               
                  const handleMergeSelect = async (e) => {
             const mergeFiles = Array.from(e.target.files);
             if (mergeFiles.length < 2) return alert("Select at least 2 PDFs.");
             
             // Check if we should use compression mode at all
             const useCompression = confirm("Enable Compression & B/W?\n\nOK = Yes (Compress new files, skip 'compressed' ones)\nCancel = No (Standard Fast Merge for all)");

             setStatusMsg(useCompression ? "Initializing Smart Engine..." : "Merging...");
             
             try {
                const newPdf = await PDFLib.PDFDocument.create();
                
                for (let fIdx = 0; fIdx < mergeFiles.length; fIdx++) {
                    const file = mergeFiles[fIdx];
                    
                    // SMART CHECK: Is it already compressed?
                    // If user said "No" to compression, OR if the file is already marked 'compressed', we skip the heavy work.
                    if (!useCompression || file.name.toLowerCase().includes('compressed')) {
                        setStatusMsg(`Fast Copy: ${file.name} (${fIdx+1}/${mergeFiles.length})`);
                        const arrayBuffer = await file.arrayBuffer();
                        const srcPdf = await PDFLib.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
                        const copiedPages = await newPdf.copyPages(srcPdf, srcPdf.getPageIndices());
                        copiedPages.forEach((page) => newPdf.addPage(page));
                    } 
                    else {
                        // HEAVY ROUTINE: Render -> Grayscale -> Compress -> Embed
                        const url = URL.createObjectURL(file);
                        const loadingTask = window.pdfjsLib.getDocument(url);
                        const pdf = await loadingTask.promise;
                        
                        for (let i = 1; i <= pdf.numPages; i++) {
                            setStatusMsg(`Compressing: ${file.name} (Pg ${i}/${pdf.numPages})`);
                            
                            const page = await pdf.getPage(i);
                            const viewport = page.getViewport({ scale: 1.5 });
                            const canvas = document.createElement('canvas');
                            canvas.width = viewport.width;
                            canvas.height = viewport.height;
                            const ctx = canvas.getContext('2d');
                            
                            // Render & Grayscale
                            await page.render({ canvasContext: ctx, viewport }).promise;
                            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const d = imgData.data;
                            for (let p = 0; p < d.length; p += 4) {
                                const gray = (0.299 * d[p]) + (0.587 * d[p+1]) + (0.114 * d[p+2]);
                                d[p] = d[p+1] = d[p+2] = gray;
                            }
                            ctx.putImageData(imgData, 0, 0);
                            
                            // Embed as JPEG (50% Quality)
                            const jpgUrl = canvas.toDataURL('image/jpeg', 0.5);
                            const jpgImageBytes = await fetch(jpgUrl).then(res => res.arrayBuffer());
                            const embeddedImg = await newPdf.embedJpg(jpgImageBytes);
                            const newPage = newPdf.addPage([viewport.width, viewport.height]);
                            newPage.drawImage(embeddedImg, { x: 0, y: 0, width: viewport.width, height: viewport.height });
                        }
                        URL.revokeObjectURL(url);
                    }
                }
                
                setStatusMsg("Saving PDF...");
                const pdfBytes = await newPdf.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                // We mark the output as 'Compressed' so it gets skipped next time!
                const fileObj = new File([blob], `Compressed_Merge_${new Date().toISOString().slice(0,10)}.pdf`, { type: 'application/pdf' });
                
                addToQueue([fileObj]);
                const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = fileObj.name; link.click();
                setStatusMsg("Smart Merge Complete!");
                
             } catch(err) { 
                 console.error(err);
                 alert("Merge Error: " + err.message); 
                 setStatusMsg("Error"); 
             }
          };
        
          // VIEW LOGIC
          const handleView = (f) => { if(selectionMode) toggleSelection(f.id); else { setSelectedFile({...f, page:1}); setIsViewerOpen(true); setShowToC(false); setIsEditingText(false); } };
          const toggleSelection = (id) => { const s = new Set(selectedIds); if(s.has(id)) s.delete(id); else s.add(id); setSelectedIds(s); };
          const selectAll = () => { if(selectedIds.size===files.length) setSelectedIds(new Set()); else setSelectedIds(new Set(files.map(f=>f.id))); };
          const bulkTag = () => { const tag = prompt("Enter tag:"); if(!tag) return; selectedIds.forEach(id => updateFileInDB(id, { tags: [] }, (old) => { const nt = [...new Set([...(old.tags||[]), tag])]; updateFileInDB(id, { tags: nt }, (n) => setFiles(p => p.map(f => f.id === id ? n : f))); })); setSelectionMode(false); setSelectedIds(new Set()); };

          const exportForGem = async () => {
             if(selectedIds.size === 0) return alert("Select files first!");
             setStatusMsg("Forging Gem Knowledge Base...");
             const db = await openDB(); const store = db.transaction(STORE_NAME, 'readonly').objectStore(STORE_NAME);
             let md = "# Gem Knowledge Base\n\n> Generated by DocuSearch\n\n## Table of Contents\n";
             let contentBody = "";
             let count = 0;
             for(const id of selectedIds) {
                await new Promise(resolve => { store.get(id).onsuccess = (e) => { const f = e.target.result; const safeName = f.name.replace(/\[|\]/g, ''); md += `- [${safeName}](#${safeName.replace(/\s/g,'-').toLowerCase()})\n`; contentBody += `\n---\n\n# ${f.name}\n**Tags:** ${f.tags.join(', ')}\n**Pages:** ${f.pageCount}\n\n`; f.textContent.forEach((pageText, idx) => { if(pageText) contentBody += `### Page ${idx+1}\n${pageText}\n\n`; }); count++; resolve(); }; });
             }
             md += "\n" + contentBody;
             const blob = new Blob([md], {type: "text/markdown"}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `Gem_KB_${new Date().toISOString().slice(0,10)}.md`; a.click();
             setStatusMsg(`Exported ${count} files!`); setSelectionMode(false); setSelectedIds(new Set());
          };

          const handleScanRequest = () => { if(selectedFile) setShowReuploadModal(true); };
          const runAIRepair = async () => { if(!selectedFile) return; if(!apiKey) { alert("Add API Key in Settings first!"); return setShowSettings(true); } document.getElementById('reupload-ai').click(); };
          const handleReuploadAI = async (e) => {
             const f = e.target.files[0]; if(!f || f.name !== selectedFile.name) return alert("Filename mismatch.");
             setStatusMsg("Sending to Gemini 2.5...");
             try {
                const url = URL.createObjectURL(f); const task = window.pdfjsLib.getDocument(url); const pdf = await task.promise; const page = await pdf.getPage(selectedFile.page||1); const vp = page.getViewport({scale:2}); const cvs = document.createElement('canvas'); cvs.width=vp.width; cvs.height=vp.height; await page.render({canvasContext:cvs.getContext('2d'), viewport:vp}).promise;
                const md = await callGemini(cvs.toDataURL('image/jpeg', 0.7), apiKey);
                const newC = [...selectedFile.textContent]; newC[(selectedFile.page||1)-1] = md;
                updateFileInDB(selectedFile.id, { textContent: newC }, (n) => setSelectedFile({...selectedFile, textContent: n.textContent}));
                setStatusMsg("Page Upgraded!");
             } catch(err) { alert(err.message); setStatusMsg(""); }
          };
          const handleKeywordClick = (keyword) => { setIsViewerOpen(false); setSearchQuery(keyword); };
          const enableEditMode = () => { const txt = selectedFile?.textContent?.[(selectedFile?.page||1)-1] || ""; setEditedTextContent(txt); setIsEditingText(true); };
          const saveEditedText = () => { if(!selectedFile) return; const pageIdx = (selectedFile.page || 1) - 1; const newContent = [...selectedFile.textContent]; newContent[pageIdx] = editedTextContent; updateFileInDB(selectedFile.id, { textContent: newContent }, (newS) => setSelectedFile({...selectedFile, textContent: newS.textContent})); setIsEditingText(false); };
          const speakText = () => { if(isSpeaking) { window.speechSynthesis.cancel(); setIsSpeaking(false); return; } if(!selectedFile) return; const txt = selectedFile.textContent[(selectedFile.page||1)-1]; if(!txt || txt==="[Image]") return alert("No text."); const u = new SpeechSynthesisUtterance(txt); u.onend = () => setIsSpeaking(false); setIsSpeaking(true); window.speechSynthesis.speak(u); };
          useEffect(() => { return () => window.speechSynthesis.cancel(); }, [selectedFile]);
          const exportData = () => { openDB().then(db => { db.transaction(STORE_NAME,'readonly').objectStore(STORE_NAME).getAll().onsuccess = (e) => { const a = document.createElement('a'); a.href = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(e.target.result)); a.download = "docusearch_master_backup.json"; a.click(); }; }); };
          const importData = (e) => { const f = e.target.files[0]; if(!f) return; const r = new FileReader(); r.onload = async (ev) => { try { const d = JSON.parse(ev.target.result); const db=await openDB(); const tx=db.transaction(STORE_NAME,'readwrite'); d.forEach(i=>tx.objectStore(STORE_NAME).put(i)); location.reload(); } catch(err){ alert("Error importing"); }}; r.readAsText(f); };

          useEffect(() => { if(!searchQuery) { setSearchResults([]); return; } const fuse = new Fuse(files, { keys: ['name', 'textContent', 'tags'], threshold: 0.3 }); setSearchResults(fuse.search(searchQuery).map(r => r.item)); }, [searchQuery, files]);
          const filteredFiles = files.filter(f => activeTagFilter ? f.tags?.includes(activeTagFilter) : true);
          const allTags = [...new Set(files.flatMap(f => f.tags || []))];
          const visibleTags = allTags.filter(t => t.toLowerCase().includes(tagQuery.toLowerCase())).sort();
          const groupedKeywords = useMemo(() => { const groups = {}; groups['Priority'] = savedSearches.filter(s => s.important); savedSearches.forEach(s => { if (s.important) return; const cat = s.category || 'General'; if (!groups[cat]) groups[cat] = []; groups[cat].push(s); }); return groups; }, [savedSearches]);

          return (
            <div className="flex flex-col h-[100dvh] bg-slate-950 text-slate-200 overflow-hidden font-sans">
              {/* HEADER */}
              <div className="pt-safe-top bg-slate-900 border-b border-slate-800 pb-2 px-4 flex items-end justify-between shadow-sm z-20">
                 <div className="flex items-center gap-2 mt-3">
                    <div className="bg-indigo-600 p-1.5 rounded-lg text-white cursor-pointer" onClick={()=>setShowSettings(!showSettings)}><Icon path={ICONS.settings} size={20}/></div>
                    <h1 className="font-bold text-lg leading-none text-white">Gem <span className="text-indigo-400">Forge</span></h1>
                 </div>
                 <div className="flex gap-2">
                    <button onClick={() => setShowSavedSearches(!showSavedSearches)} className={`p-1 ${showSavedSearches ? 'text-indigo-400' : 'text-slate-400'}`}><Icon path={ICONS.listIcon} size={22} /></button>
                    <button onClick={()=>{setSelectionMode(!selectionMode); setSelectedIds(new Set());}} className={`p-2 rounded-lg text-xs font-bold flex items-center gap-1 ${selectionMode?'bg-amber-900/50 text-amber-400 border border-amber-700':'bg-slate-800 text-slate-400'}`}>
                       <Icon path={ICONS.select} size={14}/> {selectionMode ? 'Done' : 'Select'}
                    </button>
                 </div>
              </div>

              {/* SETTINGS */}
              {showSettings && (
                <div className="bg-slate-900 text-slate-200 p-4 space-y-4 absolute top-16 left-0 right-0 z-40 shadow-xl border-b border-slate-800 animate-in slide-in-from-top-5">
                   <div className="bg-slate-800 p-3 rounded-xl border border-slate-700">
                      <label className="text-xs font-bold text-slate-500 uppercase mb-1">Gemini API Key (v2.5)</label>
                      <input type="password" value={apiKey} onChange={e=>updateApiKey(e.target.value)} placeholder="Paste key..." className="w-full bg-slate-900 p-2 rounded border border-slate-600 text-sm" />
                   </div>
                   {selectionMode && selectedIds.size > 0 && (
                      <div className="grid grid-cols-2 gap-2">
                         <button onClick={bulkTag} className="p-3 bg-indigo-600 rounded-lg font-bold text-white">Tag ({selectedIds.size})</button>
                         <button onClick={exportForGem} className="p-3 bg-amber-600 rounded-lg font-bold text-white flex justify-center gap-2"><Icon path={ICONS.gem} /> Export Gem</button>
                         {/* MAGIC WAND BUTTON */}
                         <button onClick={batchPolish} className="col-span-2 p-3 bg-fuchsia-600 rounded-lg font-bold text-white flex justify-center gap-2 border border-fuchsia-400/50"><Icon path={ICONS.wand} /> AI Batch Polish</button>
                      </div>
                   )}
                   {deferredPrompt && <button onClick={installApp} className="flex items-center gap-2 w-full p-3 bg-indigo-600 rounded-lg font-bold shadow-lg text-white"><Icon path={ICONS.download} /> Install App</button>}
                   <button onClick={exportData} className="flex items-center gap-2 w-full p-3 bg-slate-800 border border-slate-700 rounded-lg hover:bg-slate-700"><Icon path={ICONS.download} /> Backup Library</button>
                   <button onClick={() => importInputRef.current.click()} className="flex items-center gap-2 w-full p-3 bg-slate-800 border border-slate-700 rounded-lg hover:bg-slate-700"><Icon path={ICONS.upload} /> Restore Library</button>
                   <button onClick={() => { if(confirm("Reset?")) { indexedDB.deleteDatabase(DB_NAME); location.reload(); }}} className="flex items-center gap-2 w-full p-3 bg-red-900/20 text-red-400 border border-red-900/50 rounded-lg"><Icon path={ICONS.trash} /> Factory Reset</button>
                   <input type="file" ref={importInputRef} className="hidden" onChange={importData} accept=".json" />
                </div>
              )}
              
              {/* KNOWLEDGE GRAPH DRAWER */}
              {showSavedSearches && ( <div className="absolute inset-x-0 top-[4rem] bg-slate-900 border-b border-slate-800 shadow-xl z-30 max-h-[60vh] overflow-y-auto animate-in slide-in-from-top-2 flex flex-col"> <div className="p-3 border-b border-slate-800 bg-slate-900 flex justify-between items-center sticky top-0 z-10"> <h3 className="text-xs font-bold text-slate-500 uppercase">Knowledge Graph</h3> <button onClick={() => setIsEditingKeywords(!isEditingKeywords)} className={`text-xs font-bold px-3 py-1 rounded-full flex items-center gap-1 ${isEditingKeywords ? 'bg-indigo-600 text-white' : 'bg-slate-800 text-slate-400'}`}><Icon path={ICONS.edit} size={12} /> Manage</button> </div> <div className="p-4 space-y-4"> {savedSearches.length === 0 && <p className="text-sm text-slate-500 italic text-center">Star a search term to add it here.</p>} {Object.entries(groupedKeywords).map(([category, items]) => ( items.length > 0 && ( <div key={category}> <h4 className="text-[10px] font-bold text-slate-600 uppercase mb-2 tracking-wider">{category}</h4> <div className="flex flex-wrap gap-2"> {items.map(k => ( <button key={k.id} onClick={() => { if(isEditingKeywords) { setKeywordToEdit(k); } else { setSearchQuery(k.term); setShowSavedSearches(false); }}} className={`flex items-center gap-1 px-3 py-1.5 border rounded-full text-sm font-medium shadow-sm transition-all ${k.important ? 'bg-amber-900/30 border-amber-700/50 text-amber-400' : 'bg-slate-800 border-slate-700 text-slate-300'} ${isEditingKeywords ? 'hover:bg-indigo-900/30 hover:border-indigo-500' : 'active:scale-95'}`}> {k.important && <Icon path={ICONS.starFilled} size={10} className="text-amber-400" />} {k.term} {isEditingKeywords && <Icon path={ICONS.edit} size={10} className="ml-1 opacity-50" />} </button> ))} </div> </div> ) ))} </div> </div> )}
              
              {/* KEYWORD EDIT MODAL */}
              {keywordToEdit && ( <div className="absolute inset-0 z-50 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4"> <div className="bg-slate-900 border border-slate-700 rounded-2xl w-full max-w-sm p-6 shadow-2xl slide-up text-slate-200"> <h3 className="font-bold text-lg mb-4 text-white">Edit Keyword</h3> <div className="space-y-4"> <div><label className="text-xs font-bold text-slate-500 uppercase">Term</label><input type="text" value={keywordToEdit.term} onChange={(e) => setKeywordToEdit({...keywordToEdit, term: e.target.value})} className="w-full p-2 border border-slate-700 rounded-lg font-bold text-white bg-slate-800 focus:border-indigo-500 outline-none" /></div> <div> <label className="text-xs font-bold text-slate-500 uppercase">Category</label> <select value={keywordToEdit.category} onChange={(e) => setKeywordToEdit({...keywordToEdit, category: e.target.value})} className="w-full p-3 border border-slate-700 rounded-lg text-slate-200 bg-slate-800 font-medium h-12 outline-none"> <option value="General">General</option><option value="Finance">Finance</option><option value="People">People</option><option value="Technical">Technical</option><option value="Work">Work</option><option value="Personal">Personal</option><option value="Legal">Legal</option><option value="Medical">Medical</option> </select> </div> <div className="flex items-center gap-3 p-3 bg-slate-800 border border-slate-700 rounded-lg cursor-pointer" onClick={() => setKeywordToEdit({...keywordToEdit, important: !keywordToEdit.important})}> <div className={`w-5 h-5 rounded border flex items-center justify-center ${keywordToEdit.important ? 'bg-amber-500 border-amber-500 text-white' : 'bg-slate-900 border-slate-600'}`}>{keywordToEdit.important && <Icon path={ICONS.check} size={14} />}</div> <span className="text-sm font-medium">Mark as Important</span> </div> <div className="flex gap-2 pt-2"> <button onClick={() => { deleteKeyword(keywordToEdit.id); setKeywordToEdit(null); }} className="flex-1 p-3 text-red-400 font-bold bg-red-900/20 border border-red-900/50 rounded-xl">Delete</button> <button onClick={() => setKeywordToEdit(null)} className="flex-1 p-3 text-slate-400 font-bold">Cancel</button> <button onClick={() => { saveKeyword(keywordToEdit); setKeywordToEdit(null); }} className="flex-1 p-3 bg-indigo-600 text-white font-bold rounded-xl">Save</button> </div> </div> </div> </div> )}

              {/* TAG FILTER MODAL */}
              {showTagModal && (
                 <div className="absolute inset-0 z-40 bg-black/70 backdrop-blur-sm flex flex-col p-4 pt-20">
                    <div className="bg-slate-900 border border-slate-700 rounded-2xl flex flex-col max-h-full shadow-2xl overflow-hidden">
                       <div className="p-4 border-b border-slate-800 flex gap-2 items-center bg-slate-900">
                          <Icon path={ICONS.tag} size={20} className="text-indigo-400" />
                          <input type="text" autoFocus placeholder="Filter tags..." value={tagQuery} onChange={e => setTagQuery(e.target.value)} className="flex-1 bg-transparent text-white outline-none font-medium" />
                          <button onClick={() => setShowTagModal(false)}><Icon path={ICONS.close} /></button>
                       </div>
                       <div className="flex-1 overflow-y-auto p-2 space-y-1">
                          <button onClick={()=>{setActiveTagFilter(null); setShowTagModal(false);}} className="w-full text-left p-3 rounded-lg bg-indigo-900/30 text-indigo-300 border border-indigo-800 font-bold">Show All Files</button>
                          {visibleTags.map(t => (
                             <button key={t} onClick={()=>{setActiveTagFilter(t); setShowTagModal(false);}} className="w-full text-left p-3 rounded-lg hover:bg-slate-800 text-slate-300 font-medium">#{t}</button>
                          ))}
                       </div>
                    </div>
                 </div>
              )}

              {/* MAIN LIST */}
              <div className={`flex-1 flex flex-col min-h-0 bg-slate-950 transition-transform duration-300 ${isViewerOpen ? '-translate-x-1/3 opacity-50 pointer-events-none' : ''}`}>
                 <div className="p-4 space-y-3 bg-slate-900 border-b border-slate-800">
                    <div className="flex gap-2">
                       <div className="relative flex-1">
                          <div className="absolute left-3 top-3 text-slate-500"><Icon path={ICONS.search} size={16} /></div>
                          <input type="text" placeholder="Search library..." className="w-full pl-10 pr-4 py-3 bg-slate-800 border border-slate-700 text-white rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500" value={searchQuery} onChange={e => setSearchQuery(e.target.value)} />
                       </div>
                       {searchQuery.trim() && <button onClick={() => toggleQuickSave(searchQuery)} className={`p-3 rounded-xl transition-colors ${savedSearches.some(s => s.term.toLowerCase() === searchQuery.toLowerCase()) ? 'bg-amber-900/30 text-amber-400 border border-amber-700/50' : 'bg-slate-800 text-slate-400 border border-slate-700'}`}><Icon path={savedSearches.some(s => s.term.toLowerCase() === searchQuery.toLowerCase()) ? ICONS.starFilled : ICONS.star} /></button>}
                       <button onClick={()=>setShowTagModal(true)} className={`p-3 rounded-xl border transition-colors ${activeTagFilter ? 'bg-indigo-900/30 border-indigo-500 text-indigo-400' : 'bg-slate-800 border-slate-700 text-slate-400'}`}><Icon path={ICONS.filter} /></button>
                    </div>
                    <div className="flex gap-2">
                       <button onClick={() => fileInputRef.current.click()} className="flex-1 py-3 bg-indigo-600 text-white font-bold rounded-xl shadow active:scale-95 transition-transform flex justify-center gap-2 items-center"><Icon path={ICONS.upload} size={18} /> Import</button>
                       <button onClick={() => folderInputRef.current.click()} className="flex-1 py-3 bg-slate-800 border border-slate-700 text-slate-300 font-bold rounded-xl shadow active:scale-95 transition-transform flex justify-center gap-2 items-center"><Icon path={ICONS.folder} size={18} /> Folder</button>
                       <button onClick={() => mergeInputRef.current.click()} className="flex-1 py-3 bg-slate-800 border border-slate-700 text-slate-300 font-bold rounded-xl shadow active:scale-95 transition-transform flex justify-center gap-2 items-center"><Icon path={ICONS.combine} size={18} /> Merge</button>
                    </div>
                    {/* INPUTS */}
                    <input type="file" ref={fileInputRef} multiple accept=".pdf,application/pdf" className="hidden" onChange={handleFileSelect} />
                    <input type="file" ref={folderInputRef} webkitdirectory="" directory="" multiple className="hidden" onChange={handleFileSelect} />
                    <input type="file" ref={mergeInputRef} multiple accept=".pdf" className="hidden" onChange={handleMergeSelect} />

                    {(queue.length > 0 || statusMsg) && <div className="bg-indigo-900/30 p-2 rounded-lg border border-indigo-800 text-xs text-indigo-300 text-center font-mono animate-pulse">{statusMsg || `Queue: ${queue.length} remaining...`}</div>}
                 </div>

                 <div className="flex-1 overflow-y-auto p-4 pb-20 space-y-2">
                    {(searchQuery ? searchResults : filteredFiles).map(f => (
                       <div key={f.id} onClick={() => handleView(f)} className={`bg-slate-800 border ${selectionMode && selectedIds.has(f.id) ? 'border-indigo-500 ring-1 ring-indigo-500' : 'border-slate-700'} p-3 rounded-xl flex gap-3 items-center active:scale-[0.99] transition-transform`}>
                          {selectionMode && <div className={`w-5 h-5 rounded-full border flex items-center justify-center ${selectedIds.has(f.id)?'bg-indigo-500 border-indigo-500':'border-slate-500'}`}>{selectedIds.has(f.id)&&<Icon path={ICONS.check} size={12} className="text-white"/>}</div>}
                          <div className="w-10 h-12 bg-slate-900 rounded shrink-0 flex items-center justify-center overflow-hidden">{f.thumbnail ? <img src={f.thumbnail} className="w-full h-full object-cover" /> : <span className="text-xs text-slate-600">PDF</span>}</div>
                          <div className="flex-1 min-w-0">
                             <div className="font-bold text-sm text-slate-200 truncate">{f.name}</div>
                             <div className="flex gap-1 mt-1 overflow-hidden">{f.tags.map(t=><span key={t} className="text-[9px] bg-indigo-900/50 text-indigo-300 px-1 rounded font-bold border border-indigo-800">#{t}</span>)}</div>
                          </div>
                       </div>
                    ))}
                 </div>
              </div>

              {/* VIEWER */}
              <div className={`absolute inset-0 bg-slate-950 z-30 flex flex-col transition-transform duration-300 ${isViewerOpen ? 'translate-x-0' : 'translate-x-full'}`}>
                 <div className="px-4 py-3 border-b border-slate-800 flex flex-col gap-3 shrink-0 pt-safe-top bg-slate-900 shadow-sm z-20">
                    <div className="flex items-center justify-between">
                       <div className="flex items-center gap-2">
                          <button onClick={()=>setIsViewerOpen(false)} className="p-2 -ml-2 rounded-full hover:bg-slate-800 text-slate-400"><Icon path={ICONS.arrowLeft} /></button>
                          {selectedFile?.toc?.length > 0 && <button onClick={() => setShowToC(!showToC)} className={`p-2 rounded-lg flex items-center gap-1 text-xs font-bold ${showToC?'bg-indigo-900 text-indigo-300':'bg-slate-800 text-slate-400'}`}><Icon path={ICONS.listIcon} size={16} /> Index</button>}
                       </div>
                       <div className="flex gap-2">
                          <button onClick={runAIRepair} className="p-2 rounded-full bg-indigo-900/30 text-indigo-400"><Icon path={ICONS.sparkles} size={18} /></button>
                          <button onClick={() => { if(isEditingText) saveEditedText(); else enableEditMode(); }} className={`p-2 rounded-full ${isEditingText ? 'bg-green-900/30 text-green-400' : 'bg-slate-800 text-slate-400'}`}><Icon path={isEditingText ? ICONS.save : ICONS.edit} size={18} /></button>
                          <button onClick={speakText} className={`p-2 rounded-full ${isSpeaking?'bg-red-900/30 text-red-400':'bg-indigo-900/30 text-indigo-400'}`}><Icon path={isSpeaking?ICONS.stop:ICONS.speaker} size={18} /></button>
                       </div>
                    </div>
                 </div>
                 <div className="flex-1 relative overflow-hidden">
                    <div className="absolute inset-0 overflow-y-auto p-6 bg-slate-950 prose prose-invert prose-sm max-w-none">
                       {isEditingText ? (
                          <textarea className="w-full h-[60vh] p-2 border border-slate-700 rounded bg-slate-900 text-slate-300 text-lg font-serif focus:border-indigo-500 outline-none" value={editedTextContent} onChange={(e) => setEditedTextContent(e.target.value)} />
                       ) : (
                          <>
                             <div dangerouslySetInnerHTML={{__html: marked.parse(selectedFile?.textContent?.[(selectedFile?.page||1)-1] || "Empty page.")}} />
                             <HighlightedText text={selectedFile?.textContent?.[(selectedFile?.page||1)-1] || ""} keywords={savedSearches} onLinkClick={handleKeywordClick} />
                          </>
                       )}
                    </div>
                    {showToC && (
                         <div className="absolute inset-y-0 left-0 w-3/4 bg-slate-900 border-r border-slate-800 shadow-2xl z-30 animate-in slide-in-from-left overflow-y-auto">
                            <div className="p-4 border-b border-slate-800 bg-slate-900 font-bold text-sm text-slate-400 sticky top-0">Table of Contents</div>
                            {selectedFile?.toc?.length > 0 ? <ToCList items={selectedFile.toc} onSelect={(p)=>{setSelectedFile(prev=>({...prev, page:p})); setShowToC(false);}} /> : <div className="p-6 text-center text-slate-500 text-sm">No chapters found.</div>}
                         </div>
                      )}
                    <div className="absolute bottom-0 left-0 right-0 border-t border-slate-800 p-4 bg-slate-900/95 backdrop-blur pb-safe-bottom z-10 flex justify-between items-center">
                        <button disabled={(selectedFile?.page||1)<=1} onClick={()=>setSelectedFile(p=>({...p, page:p.page-1}))} className="px-5 py-3 bg-slate-800 text-slate-300 rounded-xl font-bold disabled:opacity-30">Prev</button>
                        <span className="text-xs font-mono text-slate-500">Pg {selectedFile?.page}</span>
                        <button disabled={(selectedFile?.page||1)>=(selectedFile?.pageCount||1)} onClick={()=>setSelectedFile(p=>({...p, page:p.page+1}))} className="px-5 py-3 bg-indigo-600 text-white rounded-xl font-bold disabled:opacity-30">Next</button>
                    </div>
                 </div>
                 <input type="file" id="reupload-ai" className="hidden" onChange={handleReuploadAI} />
              </div>

            </div>
          );
        }
        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
      } catch (error) { console.error(error); }
    </script>
  </body>
</html>
